.. note::

    因为 ``pcalls`` 和 ``pvalues`` 的返回值都是惰性序列，因此，如果有一个非常耗时的表达式阻塞在其他一些表达式的前面，那么就算这些表达式已经计算完了，它们也不能被返回。

    以下是这样一个实例，在序列前面的三个元素，可以立即被返回，但是，后面的三个元素只有等待 ``3`` 秒之后，才会被返回，尽管它们早就在并发线程里被求值完了：

    ::

       user=> (for [i (pvalues 1 2 3 (Thread/sleep 3000) 4 5 6)] (println i))
       (1
       2
       nil 3    ; 打印出这里之后，会停滞 3 秒
       nil nil
       nil 4
       nil 5
       nil 6
       nil nil)
